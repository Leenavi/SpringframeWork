팔도마켓 발표 대본

 슬라이드 1: 제목 슬라이드
안녕하세요. 이번에 발표를 맡은 이지혜입니다. 저희가 구현한 웹 프로젝트는 중고폰 거래를 위한 웹 플랫폼, 팔도마켓입니다. 지금부터 이 프로젝트가 어떤 구조로 만들어졌고, 어떤 기능이 포함되어 있으며, 어떻게 동작하는지를 자세히 설명드리겠습니다.

 슬라이드 2: 목차
발표는 크게 7가지로 구성됩니다. 프로젝트 개요, 개발 과정, 데이터베이스 설계, 핵심 기능 소개, 기술 스택 및 구현 구조, 그리고 마지막으로 시연과 향후 개선 방향 순서로 말씀드리겠습니다.

 슬라이드 3: 프로젝트 개요
팔도마켓은 Spring MVC와 JSP 기반의 웹 서비스로, 중고폰을 사고팔 수 있는 중고 마켓 시스템입니다. 사용자는 회원가입 없이도 게시글을 등록할 수 있으며, 상품 정보와 이미지, 판매 상태 등을 입력해서 글을 올릴 수 있습니다. 또한 검색과 페이징 기능, 수정 및 삭제, 그리고 리스트 조회와 상세 조회 기능이 포함되어 있습니다.

 슬라이드 4: 개발 과정
처음에는 요구사항을 정의하고, 각자의 역할을 나눈 뒤 화면 설계와 데이터베이스 설계를 진행했습니다. 이후 단계별로 나눠 개발을 진행했고, 마지막에 전체 통합하여 기능을 연결했습니다. 개발은 JSP와 Spring Framework를 사용했고, 데이터 연동은 MyBatis를 통해 처리했습니다.

 슬라이드 5: 데이터베이스 설계
팔도마켓은 총 4개의 테이블로 데이터베이스를 구성했습니다. pd_user는 작성자 정보를 저장하고, pd_product는 중고폰 상품의 상태, 브랜드, 모델명, 가격, 설명 등을 저장합니다. pd_board는 게시글 정보를 담고 있으며, pd_imgpath는 한 상품에 여러 장의 이미지를 등록할 수 있도록 설계한 테이블입니다. 외래키를 설정하여 테이블 간 관계를 명확하게 하고, 데이터 중복을 방지하도록 구성했습니다.

 슬라이드 6: 핵심 기능 소개
위와 같이 만들어진 데이터베이스를 이용하여 저희는 crud 기반의 게시판을 만들었습니다. 사용자가 글을 작성하고, 이미지를 업로드 할 수 있으며, 글 목록 및 상세 페이지 조회가 가능하고 검색, 페이징까지 사용자가 원하는 데이터를 빠르게 제공할 수 있도록 했습니다. 글 수정 시 데이터를 자동으로 불러와 수정하기 용이하게 하였으며, 모달 창을 활용해 수정 여부를 확인할 수 있습니다. 사용자는 글을 삭제할 수 있으며, 정상적인 삭제 여부 역시 모달창을 통해 확인이 가능합니다.

 슬라이드 7~8: 기능 구현 - 등록 기능 (Create)
등록 기능은 사용자가 register.jsp에 상품 정보를 입력하고 이미지를 업로드하면 시작됩니다. Controller에서는 MultipartFile로 대표 이미지를 받고, 이를 서버에 저장한 후 저장 경로를 board.setImgPath()로 VO에 담습니다.

이후 Service에서 insertUser → insertProduct → insertImgPath → insertBoard 순으로 4개의 insert문이 실행됩니다. 이 과정은 단일 트랜잭션으로 묶여 있어, 중간에 오류가 발생하면 전체 등록이 롤백되도록 구현되어 데이터의 정합성과 일관성이 보장됩니다.

 슬라이드 9~10: 기능 구현 - 조회 기능 (Read)
사용자가 글을 등록하면, 최신순으로 정렬된 게시글 리스트에서 바로 확인할 수 있습니다. Controller는 Criteria 객체를 통해 사용자의 요청을 받고,
Service는 Mapper의 getListWithPaging() 메서드를 호출합니다. 이때 Mapper에서는 게시글, 상품, 작성자, 대표 이미지를 한 번의 SQL 쿼리로 가져오도록 조인 처리된 SELECT문을 사용했습니다.
## (리스트를 출력할 때 데이터 양이 많을 수록 join을 쓰는 게 성능상 유리함. 1번의 쿼리로 등록된 모든 게시글 정보를 모두 가져올 수 있음)

 슬라이드 11~12: 기능 구현 - 검색, 페이징 처리 기능 (Read)
다음은 (R) Read 기능 중에서, 검색과 페이징이 실제로 어떻게 구현되었는지 구조를 보여드리는 페이지입니다.
페이지 번호와 검색 조건은 Criteria 객체로 전달됩니다. Oracle의 ROWNUM으로 페이징을 처리했고, 검색은 제목, 내용, 작성자 중 선택 항목을 OR 조건으로 필터링합니다. 결과는 JSP에 전달되어 <c:forEach>로 반복 출력되며, PageDTO를 활용한 네비게이션으로 사용자 편의성을 높였습니다.

 슬라이드 13~14: 기능 구현 - 상세페이지(Read)
리스트에서 게시글 제목을 클릭하면 boardid가 전달되고, Controller는 이 값을 받아 Service의 get 메소드를 호출합니다. 이 메소드는 게시글(BoardVO), 상품(ProductVO), 사용자(UserVO), 이미지(List<ImgPathVO>)를 각각 조회한 후 하나의 PostDTO로 묶어 모델에 전달합니다. JSP에서는 dto.board.title, dto.product.price, dto.user.nickname과 같이 필요한 정보를 꺼내어 상세 정보를 보여줍니다.
##(단 건 조회에서는 3~4번의 쿼리가 실행되므로 부담이 없음)

 슬라이드 15~16: 기능 구현 - 수정 기능 (Update)
수정 기능은 상세페이지에서 수정 버튼을 누르면 시작됩니다. 기존 데이터를 DTO 형태로 채워서 수정 폼에 미리 보여주고, 사용자가 수정한 값을 PostDTO로 받아 Controller에서 Service로 전달합니다. Service에서는 게시글과 상품 정보를 분리해서 updateBoard, updateProduct를 각각 호출하고, 두 update문이 모두 성공하면 true를 반환하여 수정 성공 여부를 판단합니다. 성공 시 FlashAttribute로 '수정 성공' 메시지를 보내고, 검색 조건을 유지한 채 게시글 리스트로 리다이렉트됩니다.
##(이때 데이터 전달용으로 DTO를 사용하는 이유는 수정 화면에 필요한 기존의 데이터를 여러 테이블에서 조회해오기 위함)

 슬라이드 17~18: 기능 구현 - 삭제 기능 (Delete)
삭제 버튼을 클릭하면 boardid가 전달되고 Controller의 remove 메소드가 호출됩니다. 서비스 클래스에서는 먼저 boardid로 게시글 정보를 조회하고, 거기서 productid를 가져옵니다. 그 다음 Mapper를 통해 이미지 → 상품 → 게시글 순으로 데이터를 삭제합니다. 이 전체 삭제 과정은 @Transactional로 처리되며, 예외 발생 시 모든 작업이 롤백되도록 try-catch 문으로 안정성을 확보했습니다. 삭제 성공 여부는 FlashAttribute로 전달되며 모달창으로 사용자에게 안내됩니다.
##(DTO는 사용하지 않지만, 게시글과 상품 정보를 처리하기 위해 BoardVO는 내부적으로 활용됩니다.)


지금까지 팔도마켓의 구조, 기능, 구현 과정을 설명드렸습니다.  다음으로 직접 시연을 하며 실제 화면을 보여드리겠습니다.

(시연하기)

home.jsp
방문자가 접속했을 때 사이트에 대한 신뢰성을 주기 위해, 자바스크립트 타이핑 효과를 활용해 핵심 메시지를 노출하였습니다. 또한 휴대폰 프레임과 배경 영상을 함께 구성하여 저희 프로젝트의 주제를 직관적으로 전달하도록 구현하였습니다.
 사용자가 사이트에 접속하면 브랜드별(Apple, Samsung,sony,LG)로 분류된 중고폰 최신 상품 리스트가 즉시 보여집니다.각 카드에는 상품 이미지, 제목, 가격이 포함되어 있으며, 클릭 시 해당 상품의 상세 페이지로 이동할 수 있도록 구성되어 있습니다.

list.jsp
게시판 버튼을 누르면 게시글 전체 목록 페이지가 나옵니다.
하단에는 PageDTO 객체를 활용한 페이징 네비게이션이 구현되어 있어, 사용자가 원하는 페이지를 클릭하면 해당 게시글 목록을 다시 조회할 수 있도록 동작합니다. 현재 페이지는 강조 표시되고, 이전/다음 버튼은 prev, next 조건에 따라 제어됩니다.

register.jsp
새로운 게시글을 등록해보겠습니다.
(프로젝트 폴더내 아이폰8.jsp 사용. 제목 : 아이폰8 8아요. 모델명 iPhone8, 가격 500000, 상태 S, 닉네임 아무거나, 설명 : 아이폰 8 8팔아요. 믿고 거래할 수 있는 8도마켓! 지금 바로 이용해보세요)
글을 등록하면 몇 번째로 등록된 글인지 안내창이 뜨며 성공적인 등록 여부를 확인 할 수 있습니다.

get.jsp
조금 전에 등록한 게시글은 제목을 클릭하면 바로 확인 할 수 있습니다.

modify.jsp(삭제 포함)
상세페이지 하단의 수정 버튼을 누르면 기존 데이터가 자동으로 입력된 수정 폼이 열립니다. 수정 후 다시 저장하면 리스트로 돌아가고, 성공 여부는 모달창으로 안내됩니다. 삭제도 같은 흐름에서 진행되며, 삭제 성공 시 마찬가지로 리스트 화면으로 이동하고 모달창으로 성공 여부를 확인할 수 있습니다.

검색기능+페이징 처리
사용자가 원하는 정보를 쉽고 빠르게 찾을 수 있도록 작성자, 제목, 내용 별로 검색이 가능하게 하고, (iPhone, Galaxy  등 검색)
게시글 상세 정보 페이지에서 목록을 누르면, 해당 게시글이 있는 페이지를 유지하도록 하여 사용자에게 편의성을 제공하였습니다.

슬라이드 19: 프로젝트 느낀 점 및 개선 방향
이번 프로젝트를 통해 Spring MVC 구조와 JSP, MyBatis의 역할을 명확히 이해할 수 있었고, Controller → Service → Mapper → DB라는 흐름 속에서 각 계층의 책임과 역할을 체감할 수 있었습니다.

슬라이드 19: 개선 방향
향후에는 이미지 저장을 AWS S3나 Google Cloud Storage와 같은 외부 저장소로 전환해 파일 관리와 전송 속도를 개선하고, 현재 단일 OR 검색 방식에서 벗어나 브랜드, 가격 범위, 정렬 기준 등 다양한 검색 옵션을 추가할 예정입니다. 또한 브랜드 리스트도 하드코딩이 아닌 DB에서 동적으로 처리해 유지보수성을 높일 계획입니다.

 슬라이드 21: 마무리
이상으로 발표를 마치겠습니다. 들어주셔서 감사합니다.



혹시나 질문이 들어오면... 
✅ [1] VO와 DTO의 차이는 무엇인가요?
답변:
VO는 DB 테이블과 1:1로 매핑되는 값 객체로, 예를 들어 BoardVO, ProductVO처럼 실제 테이블 구조에 맞게 데이터를 담습니다.
반면 DTO는 여러 VO를 묶어서 계층 간 데이터를 전달할 때 사용하는 객체로, 예를 들어 게시글, 상품, 이미지, 사용자 정보를 함께 담는 PostDTO가 있습니다.
VO는 DB 입출력용, DTO는 서비스 계층 간 데이터 전달용이라고 이해하면 됩니다.

✅ [2] 게시글 조회 시 왜 한 번에 여러 정보를 가져와야 했나요?
답변:
사용자가 게시글을 볼 때, 게시글 제목만 보는 게 아니라 상품 정보, 작성자 닉네임, 대표 이미지도 같이 보게 됩니다.
이런 정보를 한 번에 보여주려면 서로 다른 테이블에 있는 데이터를 한 번에 가져와야 하기 때문에, 실제 SQL에서는 여러 테이블을 함께 조회하는 쿼리가 필요했습니다.

✅ [3] JOIN은 배우지 않았는데, 여기서 JOIN을 왜 썼나요?
답변:
JOIN 문법 자체는 배우지 않았지만, 실무에서는 서로 다른 테이블의 데이터를 함께 보여줘야 할 때 꼭 필요합니다.
예를 들어 게시글 하나를 보여줄 때, 게시글 테이블(board), 상품 테이블(product), 사용자 테이블(user), 이미지 테이블(imgpath)에서 각각의 데이터를 가져와야 합니다.
이걸 전부 따로따로 쿼리하면 비효율적이고 복잡하므로, 한 번에 데이터를 묶어오도록 SQL에서는 JOIN을 사용했습니다.
저희는 SQL 쿼리에서 JOIN을 사용하되, 실제 Java 코드는 각 VO를 조합해서 PostDTO로 묶는 방식으로 처리했습니다.

✅ [4] DTO를 꼭 써야 하나요? VO만으로는 안 되나요?
답변:
VO만 사용하면 각 계층마다 따로따로 데이터를 전달해야 해서 코드가 복잡해집니다.
예를 들어 게시글 수정 기능에서는 게시글 VO, 상품 VO, 이미지 VO를 따로 전달하면 불편하고 실수할 수 있습니다.
DTO로 묶으면 한 번에 전달할 수 있어서 코드가 훨씬 깔끔해지고 유지보수가 쉬워집니다.

✅ [5] 등록할 때 순서를 insertUser → insertProduct → insertImgPath → insertBoard로 한 이유는?
답변:
게시글(board)은 상품(product)과 사용자(user), 이미지(imgpath)의 정보를 참조하고 있어서, 이들보다 나중에 저장해야 외래키가 맞게 들어갑니다.
예를 들어 상품이 먼저 저장돼야 게시글이 그 상품을 참조할 수 있으니까, 자연스럽게 insert 순서를 그렇게 구성했습니다.
그리고 이 모든 과정을 하나의 트랜잭션으로 묶어서, 중간에 실패하면 전부 취소되도록 만들었습니다.

✅ [6] 수정과 삭제도 트랜잭션 처리를 했나요?
답변:
네, 특히 삭제할 때는 이미지, 상품, 게시글이 서로 연결되어 있어서, 중간에 하나라도 삭제 실패하면 데이터가 꼬일 수 있습니다.
그래서 @Transactional을 사용해서 이미지 → 상품 → 게시글 삭제를 하나의 흐름으로 처리하고, 예외가 발생하면 전부 롤백되도록 했습니다.

✅ [7] 왜 ProductVO에 imgPath를 안 넣었나요?
답변:
여러 장의 이미지가 1:N으로 연결되기 때문에, 따로 ImgPathVO 리스트로 관리했습니다. 대표 이미지는 별도로 서브쿼리로 하나만 가져와서 BoardVO에 담았습니다.

✅ [8] Service에서 VO 조립하지 않고 JOIN으로 다 하면 더 낫지 않나요?
답변:
성능은 향상되지만 유지보수성이 떨어질 수 있고, 상세 조회는 VO 단위 조립이 더 유연합니다. 그래서 리스트는 JOIN, 상세는 조립 구조를 병행했습니다.

✅ [9] 비회원 게시판인데, 어떻게 사용자 구분을 하나요?
답변:
닉네임과 비밀번호를 입력받고 DB에 저장해 작성자 정보로 사용합니다. 회원 인증은 없지만 닉네임 기반 식별은 가능하도록 처리했습니다
.
✅ [10] 이미지 수정은 왜 불가능한가요?
답변:
대표 이미지 업로드는 글 등록 시 한 번만 받도록 했고, 수정 시에는 경로만 유지하고 바꾸지 않도록 설계해 안정성을 높였습니다.


